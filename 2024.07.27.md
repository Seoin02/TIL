## 코딩테스트 문제 풀이

5-2. 공통원소 구하기

## ‘포잉마켓’ 리팩토링

페이지 별 성능 측정

## 개발 아티클 & 강의 정리

### <네이버 통합 검색의 웹 성능 - 데이터 수집과 시각화>

- 출처: https://d2.naver.com/helloworld/9227596
- 웹 성능(web performance): 서비스 내용과 독립적으로 웹 플랫폼 자체가 가진 이런 사용자 경험 요소
- 사용자에게 서비스의 기능과 가치를 잘 전달하기 위해서 웹 성능과 관련된 경험을 좋게 유지해야 한다.
- 웹 바이털: 웹 성능 측정 정량 지표
  - LCP: 화면에서 가장 큰 요소가 표시될 때까지 걸리는 시간
  - INP: 화면에서 사용자가 여러 인터랙션을 수행했을 때 그중 가장 느렸던 반응 시간
  - CLS: 화면에서 예상치 못한 레이아웃 이동이 얼마나 발생했는지를 측정
  - FCP: 화면에서 처음으로 그려진 요소가 표시될 때까지 걸린 시간을 측정
- 실험실 데이터: 특정 조건이 고정된 환경에서 측정한 데이터 ⇒ Lighthouse로 웹 성능 진단 ⇒ 변화가 많은 페이지에서 일일이 측정하는 것은 불가능하다.
- 필드 데이터: 실제 사용자 환경에서 측정한 데이터 ⇒ 가변적인 데이터를 일일이 측정하는 게 불가하기 때문에 웹 성능 현황을 파악하기 위해서 수집 필수
- 네이버에서 사용하는 LCP 측정 라이브러리: https://web.dev/articles/vitals?hl=ko
- 구글에서 제시하는 LCP 가이드라인
  ![LCP 가이드라인](./LCP%20기준.png)

### <네이버 통합 검색의 웹 성능 - 모니터링과 성능 개선>

- 출처: https://d2.naver.com/helloworld/8113611
- 주기적으로 성능 리포트 발행
- 문제 발생 시 빠르게 감지하기 위해 성능 알람 발송
- LCP 변화가 감지될 때 확인하는 부분
  - 서버 응답 시간을 확인하고, timeout이 발생하지 않았는지 확인
  - 서버 응답 시간에 문제가 없다면 배포 등 클라이언트 성능 변화를 원인으로 예상한다.
  - 사용자 검색어의 변화나 로그 수의 변화 확인
- 새로운 기능은 기존보다 느리게 실행될 확률이 높다. 미래의 고도화될 기능을 위해서라도 성능 관리가 필요하다.
- 관련 사례
  - 웹 성능이 안 좋은 검색 환경에 오래 노출된 사용자가 더 적게 검색했다.
  - 보다폰 LCP 31% 개선으로 매출 8% 증가
  - LCP가 느려질수록 rage click 수치 증가
- 조금씩 느려지는 성능을 간과하면 어느 순간 큰 위험이 될 수 있다. 더 나은 서비스를 위해서 작은 수치라도 성능 개선을 위해 노력해야 한다.
- [Speculation Rules API](https://www.jeong-min.com/69-speculation-rules-api/)

### <선언적인 코드 작성하기>

- 출처: https://toss.tech/article/frontend-declarative-code
- 선언적인 코드: 추상화 레벨이 높아진 코드

```jsx
for (const num of nums) {
}
```

- for … of문은 배열이 가지고 있는 각각의 요소를 순회하는 동작을 추상화하고 있다.
- 그러나 선언적인 코드도 사용되는 맥락에 따라 수정하기 쉬운 코드로 추상화해 작성해야 한다.
- 토스의 선언전 라이브러리
  - useOverlay: 오버레이 띄우는 동작 추상화한 hook
  - ImpressionArea: 어떤 영역이 보여지거나 숨겨질 때 동작하는 로직을 넣은 컴포넌트
  - LoggingClick: 누르는 동작을 기록하는 컴포넌트(데이터 주도 의사결정)

### <프론트엔드 개발자가 알아야 할 ‘캐싱’ 개념 정리>

- 출처: https://yozm.wishket.com/magazine/detail/2341/
- **캐싱**: 데이터를 한 번 받아온 후 그 데이터를 불러온 저장소보다 가까운 곳에 임시로 저장해 필요한 경우 더 빠르게 불러올 수 있는 프로세스
- 캐싱은 로딩 시간을 줄이고, 사용자 경험을 향상시키는 데 기여한다.
- 캐시는 메모리 계층 구조에서 레지스트리 다음으로 빠르게 데이터에 접근할 수 있다.
- **웹 캐시**
  - 반복 사용되는 요소들을 임시 저장해 서버로부터 반복적인 요청을 줄이는 역할을 한다.
  - 블로그의 사이드바, 썸네일처럼 여러 페이지에서 공통으로 사용되는 요소에 사용한다.
  - 불필요한 데이터 전송을 줄여 네트워크 대역폭도 절약할 수 있다.
- **브라우저 캐시**
  - 클라이언트 측에서 HTTP 요청으로 불러온 데이터를 로컬 디스크에 저장한다.
  - 사용자가 자주 방문하는 웹 페이지의 로딩 시간을 단축시킨다.
  - 자주 사용되는 이미지, CSS, 자바스크립트 파일을 빠르게 로드할 수 있다.
- **프록시 캐시**
  - 여러 사용자가 동일한 데이터를 빠르게 불러올 수 있게 중간 서버에 데이터를 저장한다.
  - 대규모 트래픽을 처리할 때 매우 유용하고, 서버 부하를 줄이는 데 도움을 준다.
- **네트워크 캐시**
  - 여러 프록시 서버를 통해 관리되며, 콘텐츠 전송 네트워크를 통해 전 세계 사용자에게 빠르게 콘텐츠를 제공한다. / 일관된 성능 제공
  - CDN: 분산 노드를 통해 콘텐츠를 사용자 가까이에 저장해 빠르게 전달한다.
- 캐싱을 사용할 때 고려해야 할 부분
  - stale 데이터가 유저에게 노출되지 않게 주의해야 한다.
  - 캐싱이 불필요한 저장 공간을 차지하지 않는지 확인해야 한다.
  - 캐싱은 초기 설정과 모니터링이 중요하고, 필요할 때 캐시를 갱신하고 무효화하는 작업도 필요하다.

### <Vanilla Javascript로 웹 컴포넌트 만들기>

- 출처: https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Component/#_1-상태관리의-탄생
- 바닐라 자바스크립트로 개발할 때 참고해야겠다. 이렇게 포스팅을 정리해야지!
